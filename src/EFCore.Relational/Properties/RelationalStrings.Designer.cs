// <auto-generated />

using System;
using System.Reflection;
using System.Resources;
using System.Threading;
using JetBrains.Annotations;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Logging;

namespace Microsoft.EntityFrameworkCore.Diagnostics
{
    /// <summary>
    ///     <para>
    ///		    String resources used in EF exceptions, etc.
    ///     </para>
    ///     <para>
    ///		    These strings are exposed publicly for use by database providers and extensions.
    ///         It is unusual for application code to need these strings.
    ///     </para>
    /// </summary>
    public static class RelationalStrings
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Microsoft.EntityFrameworkCore.Properties.RelationalStrings", typeof(RelationalStrings).GetTypeInfo().Assembly);

        /// <summary>
        ///     Cannot save changes for an entity in state '{entityState}'.
        /// </summary>
        public static string ModificationCommandInvalidEntityState([CanBeNull] object entityState)
            => string.Format(
                GetString("ModificationCommandInvalidEntityState", nameof(entityState)),
                entityState);

        /// <summary>
        ///     Database operation expected to affect {expectedRows} row(s) but actually affected {actualRows} row(s). Data may have been modified or deleted since entities were loaded. See http://go.microsoft.com/fwlink/?LinkId=527962 for information on understanding and handling optimistic concurrency exceptions.
        /// </summary>
        public static string UpdateConcurrencyException([CanBeNull] object expectedRows, [CanBeNull] object actualRows)
            => string.Format(
                GetString("UpdateConcurrencyException", nameof(expectedRows), nameof(actualRows)),
                expectedRows, actualRows);

        /// <summary>
        ///     Multiple relational database provider configurations found. A context can only be configured to use a single database provider.
        /// </summary>
        public static string MultipleProvidersConfigured
            => GetString("MultipleProvidersConfigured");

        /// <summary>
        ///     No relational database providers are configured. Configure a database provider using OnConfiguring or by creating an ImmutableDbContextOptions with a database provider configured and passing it to the context.
        /// </summary>
        public static string NoProviderConfigured
            => GetString("NoProviderConfigured");

        /// <summary>
        ///     Both an existing DbConnection and a connection string have been configured. When an existing DbConnection is used the connection string must be set on that connection.
        /// </summary>
        public static string ConnectionAndConnectionString
            => GetString("ConnectionAndConnectionString");

        /// <summary>
        ///     A relational store has been configured without specifying either the DbConnection or connection string to use.
        /// </summary>
        public static string NoConnectionOrConnectionString
            => GetString("NoConnectionOrConnectionString");

        /// <summary>
        ///     A named connection string was used, but the name '{name}' was not found in the application's configuration. Note that named connection strings are only supported when using 'IConfiguration' and a service provider, such as in a typical ASP.NET Core application. See https://go.microsoft.com/fwlink/?linkid=850912 for more information.
        /// </summary>
        public static string NamedConnectionStringNotFound([CanBeNull] object name)
            => string.Format(
                GetString("NamedConnectionStringNotFound", nameof(name)),
                name);

        /// <summary>
        ///     No mapping to a relational type can be found for the CLR type '{clrType}'.
        /// </summary>
        public static string UnsupportedType([CanBeNull] object clrType)
            => string.Format(
                GetString("UnsupportedType", nameof(clrType)),
                clrType);

        /// <summary>
        ///     Relational-specific methods can only be used when the context is using a relational database provider.
        /// </summary>
        public static string RelationalNotInUse
            => GetString("RelationalNotInUse");

        /// <summary>
        ///     An error occurred while updating the entries. See the inner exception for details.
        /// </summary>
        public static string UpdateStoreException
            => GetString("UpdateStoreException");

        /// <summary>
        ///     The connection is already in a transaction and cannot participate in another transaction.
        /// </summary>
        public static string TransactionAlreadyStarted
            => GetString("TransactionAlreadyStarted");

        /// <summary>
        ///     The specified transaction is not associated with the current connection. Only transactions associated with the current connection may be used.
        /// </summary>
        public static string TransactionAssociatedWithDifferentConnection
            => GetString("TransactionAssociatedWithDifferentConnection");

        /// <summary>
        ///     Invalid type for sequence. Valid types are 'Int64' (the default), 'Int32', 'Int16', 'Byte' and 'Decimal'.
        /// </summary>
        public static string BadSequenceType
            => GetString("BadSequenceType");

        /// <summary>
        ///     Unable to deserialize sequence from model metadata. See inner exception for details.
        /// </summary>
        public static string BadSequenceString
            => GetString("BadSequenceString");

        /// <summary>
        ///     Unable to deserialize check constraint from model metadata. See inner exception for details.
        /// </summary>
        public static string BadCheckConstraintString
            => GetString("BadCheckConstraintString");

        /// <summary>
        ///     The migration '{migrationName}' was not found.
        /// </summary>
        public static string MigrationNotFound([CanBeNull] object migrationName)
            => string.Format(
                GetString("MigrationNotFound", nameof(migrationName)),
                migrationName);

        /// <summary>
        ///     The current migration SQL generator '{sqlGeneratorType}' is unable to generate SQL for operations of type '{operationType}'.
        /// </summary>
        public static string UnknownOperation([CanBeNull] object sqlGeneratorType, [CanBeNull] object operationType)
            => string.Format(
                GetString("UnknownOperation", nameof(sqlGeneratorType), nameof(operationType)),
                sqlGeneratorType, operationType);

        /// <summary>
        ///     The specified CommandTimeout value is not valid. It must be a positive number.
        /// </summary>
        public static string InvalidCommandTimeout
            => GetString("InvalidCommandTimeout");

        /// <summary>
        ///     The specified MaxBatchSize value is not valid. It must be a positive number.
        /// </summary>
        public static string InvalidMaxBatchSize
            => GetString("InvalidMaxBatchSize");

        /// <summary>
        ///     The Include operation is not supported when calling a stored procedure.
        /// </summary>
        public static string StoredProcedureIncludeNotSupported
            => GetString("StoredProcedureIncludeNotSupported");

        /// <summary>
        ///     The required column '{column}' was not present in the results of a 'FromSql' operation.
        /// </summary>
        public static string FromSqlMissingColumn([CanBeNull] object column)
            => string.Format(
                GetString("FromSqlMissingColumn", nameof(column)),
                column);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and the name '{keyName}' of the primary key {primaryKey} does not match the name '{otherName}' of the primary key {otherPrimaryKey}.
        /// </summary>
        public static string IncompatibleTableKeyNameMismatch([CanBeNull] object table, [CanBeNull] object entityType, [CanBeNull] object otherEntityType, [CanBeNull] object keyName, [CanBeNull] object primaryKey, [CanBeNull] object otherName, [CanBeNull] object otherPrimaryKey)
            => string.Format(
                GetString("IncompatibleTableKeyNameMismatch", nameof(table), nameof(entityType), nameof(otherEntityType), nameof(keyName), nameof(primaryKey), nameof(otherName), nameof(otherPrimaryKey)),
                table, entityType, otherEntityType, keyName, primaryKey, otherName, otherPrimaryKey);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and the comment '{comment}' does not match the comment '{otherComment}'.
        /// </summary>
        public static string IncompatibleTableCommentMismatch([CanBeNull] object table, [CanBeNull] object entityType, [CanBeNull] object otherEntityType, [CanBeNull] object comment, [CanBeNull] object otherComment)
            => string.Format(
                GetString("IncompatibleTableCommentMismatch", nameof(table), nameof(entityType), nameof(otherEntityType), nameof(comment), nameof(otherComment)),
                table, entityType, otherEntityType, comment, otherComment);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and there is no relationship between their primary keys.
        /// </summary>
        public static string IncompatibleTableNoRelationship([CanBeNull] object table, [CanBeNull] object entityType, [CanBeNull] object otherEntityType)
            => string.Format(
                GetString("IncompatibleTableNoRelationship", nameof(table), nameof(entityType), nameof(otherEntityType)),
                table, entityType, otherEntityType);

        /// <summary>
        ///     No value provided for required parameter '{parameter}'.
        /// </summary>
        public static string MissingParameterValue([CanBeNull] object parameter)
            => string.Format(
                GetString("MissingParameterValue", nameof(parameter)),
                parameter);

        /// <summary>
        ///     Cannot use the value provided for parameter '{parameter}' because it isn't assignable to type object[].
        /// </summary>
        public static string ParameterNotObjectArray([CanBeNull] object parameter)
            => string.Format(
                GetString("ParameterNotObjectArray", nameof(parameter)),
                parameter);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured to use different data types ('{dataType1}' and '{dataType2}').
        /// </summary>
        public static string DuplicateColumnNameDataTypeMismatch([CanBeNull] object entityType1, [CanBeNull] object property1, [CanBeNull] object entityType2, [CanBeNull] object property2, [CanBeNull] object columnName, [CanBeNull] object table, [CanBeNull] object dataType1, [CanBeNull] object dataType2)
            => string.Format(
                GetString("DuplicateColumnNameDataTypeMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(dataType1), nameof(dataType2)),
                entityType1, property1, entityType2, property2, columnName, table, dataType1, dataType2);

        /// <summary>
        ///     The connection does not have any active transactions.
        /// </summary>
        public static string NoActiveTransaction
            => GetString("NoActiveTransaction");

        /// <summary>
        ///     An instance of entity type '{firstEntityType}' is marked as '{firstState}', but an instance of entity type '{secondEntityType}' is marked as '{secondState}' and both are mapped to the same row. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the key values.
        /// </summary>
        public static string ConflictingRowUpdateTypes([CanBeNull] object firstEntityType, [CanBeNull] object firstState, [CanBeNull] object secondEntityType, [CanBeNull] object secondState)
            => string.Format(
                GetString("ConflictingRowUpdateTypes", nameof(firstEntityType), nameof(firstState), nameof(secondEntityType), nameof(secondState)),
                firstEntityType, firstState, secondEntityType, secondState);

        /// <summary>
        ///     The instance of entity type '{firstEntityType}' with the key value '{firstKeyValue}' is marked as '{firstState}', but the instance of entity type '{secondEntityType}' with the key value '{secondKeyValue}' is marked as '{secondState}' and both are mapped to the same row.
        /// </summary>
        public static string ConflictingRowUpdateTypesSensitive([CanBeNull] object firstEntityType, [CanBeNull] object firstKeyValue, [CanBeNull] object firstState, [CanBeNull] object secondEntityType, [CanBeNull] object secondKeyValue, [CanBeNull] object secondState)
            => string.Format(
                GetString("ConflictingRowUpdateTypesSensitive", nameof(firstEntityType), nameof(firstKeyValue), nameof(firstState), nameof(secondEntityType), nameof(secondKeyValue), nameof(secondState)),
                firstEntityType, firstKeyValue, firstState, secondEntityType, secondKeyValue, secondState);

        /// <summary>
        ///     An instance of entity type '{firstEntityType}' and an instance of entity type '{secondEntityType}' are mapped to the same row, but have different property values for the properties {firstProperties} and {secondProperties} mapped to {columns}. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the conflicting values.
        /// </summary>
        public static string ConflictingRowValues([CanBeNull] object firstEntityType, [CanBeNull] object secondEntityType, [CanBeNull] object firstProperties, [CanBeNull] object secondProperties, [CanBeNull] object columns)
            => string.Format(
                GetString("ConflictingRowValues", nameof(firstEntityType), nameof(secondEntityType), nameof(firstProperties), nameof(secondProperties), nameof(columns)),
                firstEntityType, secondEntityType, firstProperties, secondProperties, columns);

        /// <summary>
        ///     The instance of entity type '{firstEntityType}' and the instance of entity type '{secondEntityType}' are mapped to the same row with the key value '{keyValue}', but have different property values '{firstConflictingValues}' and '{secondConflictingValues}' mapped to {columns}.
        /// </summary>
        public static string ConflictingRowValuesSensitive([CanBeNull] object firstEntityType, [CanBeNull] object secondEntityType, [CanBeNull] object keyValue, [CanBeNull] object firstConflictingValues, [CanBeNull] object secondConflictingValues, [CanBeNull] object columns)
            => string.Format(
                GetString("ConflictingRowValuesSensitive", nameof(firstEntityType), nameof(secondEntityType), nameof(keyValue), nameof(firstConflictingValues), nameof(secondConflictingValues), nameof(columns)),
                firstEntityType, secondEntityType, keyValue, firstConflictingValues, secondConflictingValues, columns);

        /// <summary>
        ///     An instance of entity type '{firstEntityType}' and an instance of entity type '{secondEntityType}' are mapped to the same row, but have different original property values for the properties {firstProperties} and {secondProperties} mapped to {columns}. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the conflicting values.
        /// </summary>
        public static string ConflictingOriginalRowValues([CanBeNull] object firstEntityType, [CanBeNull] object secondEntityType, [CanBeNull] object firstProperties, [CanBeNull] object secondProperties, [CanBeNull] object columns)
            => string.Format(
                GetString("ConflictingOriginalRowValues", nameof(firstEntityType), nameof(secondEntityType), nameof(firstProperties), nameof(secondProperties), nameof(columns)),
                firstEntityType, secondEntityType, firstProperties, secondProperties, columns);

        /// <summary>
        ///     The instance of entity type '{firstEntityType}' and the instance of entity type '{secondEntityType}' are mapped to the same row with the key value '{keyValue}', but have different original property values '{firstConflictingValues}' and '{secondConflictingValues}' mapped to {columns}.
        /// </summary>
        public static string ConflictingOriginalRowValuesSensitive([CanBeNull] object firstEntityType, [CanBeNull] object secondEntityType, [CanBeNull] object keyValue, [CanBeNull] object firstConflictingValues, [CanBeNull] object secondConflictingValues, [CanBeNull] object columns)
            => string.Format(
                GetString("ConflictingOriginalRowValuesSensitive", nameof(firstEntityType), nameof(secondEntityType), nameof(keyValue), nameof(firstConflictingValues), nameof(secondConflictingValues), nameof(columns)),
                firstEntityType, secondEntityType, keyValue, firstConflictingValues, secondConflictingValues, columns);

        /// <summary>
        ///     The entity of type '{entityType}' is sharing the table '{tableName}' with entities of type '{missingEntityType}', but there is no entity of this type with the same key value that has been marked as '{state}'. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the key values.
        /// </summary>
        public static string SharedRowEntryCountMismatch([CanBeNull] object entityType, [CanBeNull] object tableName, [CanBeNull] object missingEntityType, [CanBeNull] object state)
            => string.Format(
                GetString("SharedRowEntryCountMismatch", nameof(entityType), nameof(tableName), nameof(missingEntityType), nameof(state)),
                entityType, tableName, missingEntityType, state);

        /// <summary>
        ///     The entity of type '{entityType}' is sharing the table '{tableName}' with entities of type '{missingEntityType}', but there is no entity of this type with the same key value '{keyValue}' that has been marked as '{state}'.
        /// </summary>
        public static string SharedRowEntryCountMismatchSensitive([CanBeNull] object entityType, [CanBeNull] object tableName, [CanBeNull] object missingEntityType, [CanBeNull] object keyValue, [CanBeNull] object state)
            => string.Format(
                GetString("SharedRowEntryCountMismatchSensitive", nameof(entityType), nameof(tableName), nameof(missingEntityType), nameof(keyValue), nameof(state)),
                entityType, tableName, missingEntityType, keyValue, state);

        /// <summary>
        ///     Cannot set default value '{value}' of type '{valueType}' on property '{property}' of type '{propertyType}' in entity type '{entityType}'.
        /// </summary>
        public static string IncorrectDefaultValueType([CanBeNull] object value, [CanBeNull] object valueType, [CanBeNull] object property, [CanBeNull] object propertyType, [CanBeNull] object entityType)
            => string.Format(
                GetString("IncorrectDefaultValueType", nameof(value), nameof(valueType), nameof(property), nameof(propertyType), nameof(entityType)),
                value, valueType, property, propertyType, entityType);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured with different nullability.
        /// </summary>
        public static string DuplicateColumnNameNullabilityMismatch([CanBeNull] object entityType1, [CanBeNull] object property1, [CanBeNull] object entityType2, [CanBeNull] object property2, [CanBeNull] object columnName, [CanBeNull] object table)
            => string.Format(
                GetString("DuplicateColumnNameNullabilityMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured to use different computed values ('{value1}' and '{value2}').
        /// </summary>
        public static string DuplicateColumnNameComputedSqlMismatch([CanBeNull] object entityType1, [CanBeNull] object property1, [CanBeNull] object entityType2, [CanBeNull] object property2, [CanBeNull] object columnName, [CanBeNull] object table, [CanBeNull] object value1, [CanBeNull] object value2)
            => string.Format(
                GetString("DuplicateColumnNameComputedSqlMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(value1), nameof(value2)),
                entityType1, property1, entityType2, property2, columnName, table, value1, value2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured to use different default values ('{value1}' and '{value2}').
        /// </summary>
        public static string DuplicateColumnNameDefaultSqlMismatch([CanBeNull] object entityType1, [CanBeNull] object property1, [CanBeNull] object entityType2, [CanBeNull] object property2, [CanBeNull] object columnName, [CanBeNull] object table, [CanBeNull] object value1, [CanBeNull] object value2)
            => string.Format(
                GetString("DuplicateColumnNameDefaultSqlMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(value1), nameof(value2)),
                entityType1, property1, entityType2, property2, columnName, table, value1, value2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured to use different comments ('{comment1}' and '{comment2}').
        /// </summary>
        public static string DuplicateColumnNameCommentMismatch([CanBeNull] object entityType1, [CanBeNull] object property1, [CanBeNull] object entityType2, [CanBeNull] object property2, [CanBeNull] object columnName, [CanBeNull] object table, [CanBeNull] object comment1, [CanBeNull] object comment2)
            => string.Format(
                GetString("DuplicateColumnNameCommentMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(comment1), nameof(comment2)),
                entityType1, property1, entityType2, property2, columnName, table, comment1, comment2);

        /// <summary>
        ///     {conflictingConfiguration} cannot be set for '{property}' at the same time as {existingConfiguration}. Remove one of these values.
        /// </summary>
        public static string ConflictingColumnServerGeneration([CanBeNull] object conflictingConfiguration, [CanBeNull] object property, [CanBeNull] object existingConfiguration)
            => string.Format(
                GetString("ConflictingColumnServerGeneration", nameof(conflictingConfiguration), nameof(property), nameof(existingConfiguration)),
                conflictingConfiguration, property, existingConfiguration);

        /// <summary>
        ///     The check constraint '{checkConstraint}' cannot be added to the entity type '{entityType}' because another check constraint with the same name already exists.
        /// </summary>
        public static string DuplicateCheckConstraint([CanBeNull] object checkConstraint, [CanBeNull] object entityType)
            => string.Format(
                GetString("DuplicateCheckConstraint", nameof(checkConstraint), nameof(entityType)),
                checkConstraint, entityType);

        /// <summary>
        ///     The foreign keys {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}' but use different columns ({columnNames1} and {columnNames2}).
        /// </summary>
        public static string DuplicateForeignKeyColumnMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object foreignKeyName, [CanBeNull] object columnNames1, [CanBeNull] object columnNames2)
            => string.Format(
                GetString("DuplicateForeignKeyColumnMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(columnNames1), nameof(columnNames2)),
                index1, entityType1, index2, entityType2, table, foreignKeyName, columnNames1, columnNames2);

        /// <summary>
        ///     The foreign keys {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}' but with different delete behavior ('{deleteBehavior1}' and '{deleteBehavior2}').
        /// </summary>
        public static string DuplicateForeignKeyDeleteBehaviorMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object foreignKeyName, [CanBeNull] object deleteBehavior1, [CanBeNull] object deleteBehavior2)
            => string.Format(
                GetString("DuplicateForeignKeyDeleteBehaviorMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(deleteBehavior1), nameof(deleteBehavior2)),
                index1, entityType1, index2, entityType2, table, foreignKeyName, deleteBehavior1, deleteBehavior2);

        /// <summary>
        ///     The foreign keys {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}' but referencing different principal columns ({principalColumnNames1} and {principalColumnNames2}).
        /// </summary>
        public static string DuplicateForeignKeyPrincipalColumnMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object foreignKeyName, [CanBeNull] object principalColumnNames1, [CanBeNull] object principalColumnNames2)
            => string.Format(
                GetString("DuplicateForeignKeyPrincipalColumnMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(principalColumnNames1), nameof(principalColumnNames2)),
                index1, entityType1, index2, entityType2, table, foreignKeyName, principalColumnNames1, principalColumnNames2);

        /// <summary>
        ///     The foreign keys {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}' but referencing different principal tables ('{principalTable1}' and '{principalTable2}').
        /// </summary>
        public static string DuplicateForeignKeyPrincipalTableMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object foreignKeyName, [CanBeNull] object principalTable1, [CanBeNull] object principalTable2)
            => string.Format(
                GetString("DuplicateForeignKeyPrincipalTableMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(principalTable1), nameof(principalTable2)),
                index1, entityType1, index2, entityType2, table, foreignKeyName, principalTable1, principalTable2);

        /// <summary>
        ///     The foreign keys {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}' but with different uniqueness.
        /// </summary>
        public static string DuplicateForeignKeyUniquenessMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object foreignKeyName)
            => string.Format(
                GetString("DuplicateForeignKeyUniquenessMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(foreignKeyName)),
                index1, entityType1, index2, entityType2, table, foreignKeyName);

        /// <summary>
        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}' but with different columns ({columnNames1} and {columnNames2}).
        /// </summary>
        public static string DuplicateIndexColumnMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object indexName, [CanBeNull] object columnNames1, [CanBeNull] object columnNames2)
            => string.Format(
                GetString("DuplicateIndexColumnMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName), nameof(columnNames1), nameof(columnNames2)),
                index1, entityType1, index2, entityType2, table, indexName, columnNames1, columnNames2);

        /// <summary>
        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}' but with different uniqueness.
        /// </summary>
        public static string DuplicateIndexUniquenessMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object indexName)
            => string.Format(
                GetString("DuplicateIndexUniquenessMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
                index1, entityType1, index2, entityType2, table, indexName);

        /// <summary>
        ///     The keys {key1} on '{entityType1}' and {key2} on '{entityType2}' are both mapped to '{table}.{keyName}' but with different columns ({columnNames1} and {columnNames2}).
        /// </summary>
        public static string DuplicateKeyColumnMismatch([CanBeNull] object key1, [CanBeNull] object entityType1, [CanBeNull] object key2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object keyName, [CanBeNull] object columnNames1, [CanBeNull] object columnNames2)
            => string.Format(
                GetString("DuplicateKeyColumnMismatch", nameof(key1), nameof(entityType1), nameof(key2), nameof(entityType2), nameof(table), nameof(keyName), nameof(columnNames1), nameof(columnNames2)),
                key1, entityType1, key2, entityType2, table, keyName, columnNames1, columnNames2);

        /// <summary>
        ///     No mapping to a relational type can be found for property '{entity}.{property}' with the CLR type '{clrType}'.
        /// </summary>
        public static string UnsupportedPropertyType([CanBeNull] object entity, [CanBeNull] object property, [CanBeNull] object clrType)
            => string.Format(
                GetString("UnsupportedPropertyType", nameof(entity), nameof(property), nameof(clrType)),
                entity, property, clrType);

        /// <summary>
        ///     Sequence contains no elements.
        /// </summary>
        public static string NoElements
            => GetString("NoElements");

        /// <summary>
        ///     Timeout must be greater than or equal to zero.  Provided: {seconds} seconds.
        /// </summary>
        public static string TimeoutTooSmall([CanBeNull] object seconds)
            => string.Format(
                GetString("TimeoutTooSmall", nameof(seconds)),
                seconds);

        /// <summary>
        ///     Timeout must be less than or equal to Int32.MaxValue (2147483647) seconds.  Provided: {seconds} seconds.
        /// </summary>
        public static string TimeoutTooBig([CanBeNull] object seconds)
            => string.Format(
                GetString("TimeoutTooBig", nameof(seconds)),
                seconds);

        /// <summary>
        ///     The DbFunction '{function}' has an invalid return type '{type}'. Ensure that the return type can be mapped by the current provider.
        /// </summary>
        public static string DbFunctionInvalidReturnType([CanBeNull] object function, [CanBeNull] object type)
            => string.Format(
                GetString("DbFunctionInvalidReturnType", nameof(function), nameof(type)),
                function, type);

        /// <summary>
        ///     The DbFunction '{function}' has no name set. Name is a required property of a DbFunction.
        /// </summary>
        public static string DbFunctionNameEmpty([CanBeNull] object function)
            => string.Format(
                GetString("DbFunctionNameEmpty", nameof(function)),
                function);

        /// <summary>
        ///     The parameter '{parameter}' for the DbFunction '{function}' has an invalid type '{type}'. Ensure the parameter type can be mapped by the current provider.
        /// </summary>
        public static string DbFunctionInvalidParameterType([CanBeNull] object parameter, [CanBeNull] object function, [CanBeNull] object type)
            => string.Format(
                GetString("DbFunctionInvalidParameterType", nameof(parameter), nameof(function), nameof(type)),
                parameter, function, type);

        /// <summary>
        ///     The DbFunction '{function}' does not have a parameter named '{parameter}'.
        /// </summary>
        public static string DbFunctionInvalidParameterName([CanBeNull] object function, [CanBeNull] object parameter)
            => string.Format(
                GetString("DbFunctionInvalidParameterName", nameof(function), nameof(parameter)),
                function, parameter);

        /// <summary>
        ///     The DbFunction '{function}' is generic. Generic methods are not supported.
        /// </summary>
        public static string DbFunctionGenericMethodNotSupported([CanBeNull] object function)
            => string.Format(
                GetString("DbFunctionGenericMethodNotSupported", nameof(function)),
                function);

        /// <summary>
        ///     The provided DbFunction expression '{expression}' is invalid. The expression should be a lambda expression containing a single method call to the target static method. Default values can be provided as arguments if required. E.g. () =&gt; SomeClass.SomeMethod(null, 0)
        /// </summary>
        public static string DbFunctionExpressionIsNotMethodCall([CanBeNull] object expression)
            => string.Format(
                GetString("DbFunctionExpressionIsNotMethodCall", nameof(expression)),
                expression);

        /// <summary>
        ///     The DbFunction '{function}' defined on type '{type}' must be either a static method or an instance method defined on a DbContext subclass. Instance methods on other types are not supported.
        /// </summary>
        public static string DbFunctionInvalidInstanceType([CanBeNull] object function, [CanBeNull] object type)
            => string.Format(
                GetString("DbFunctionInvalidInstanceType", nameof(function), nameof(type)),
                function, type);

        /// <summary>
        ///     An ambient transaction has been detected. The ambient transaction needs to be completed before beginning a transaction on this connection.
        /// </summary>
        public static string ConflictingAmbientTransaction
            => GetString("ConflictingAmbientTransaction");

        /// <summary>
        ///     The connection is currently enlisted in a transaction. The enlisted transaction needs to be completed before starting a transaction.
        /// </summary>
        public static string ConflictingEnlistedTransaction
            => GetString("ConflictingEnlistedTransaction");

        /// <summary>
        ///     The specified MinBatchSize value is not valid. It must be a positive number.
        /// </summary>
        public static string InvalidMinBatchSize
            => GetString("InvalidMinBatchSize");

        /// <summary>
        ///     Expected a non-null value for query parameter '{parameter}'.
        /// </summary>
        public static string ExpectedNonNullParameter([CanBeNull] object parameter)
            => string.Format(
                GetString("ExpectedNonNullParameter", nameof(parameter)),
                parameter);

        /// <summary>
        ///     The entity type '{entityType}' cannot be mapped to a table because it is derived from '{baseType}'. Only base entity types can be mapped to a table.
        /// </summary>
        public static string DerivedTypeTable([CanBeNull] object entityType, [CanBeNull] object baseType)
            => string.Format(
                GetString("DerivedTypeTable", nameof(entityType), nameof(baseType)),
                entityType, baseType);

        /// <summary>
        ///     The '{mapping}' does not support 2.2 style type mapping. The database provider needs to be updated to support the full set of mapping customization.
        /// </summary>
        public static string RelationalCloneNotImplemented([CanBeNull] object mapping)
            => string.Format(
                GetString("RelationalCloneNotImplemented", nameof(mapping)),
                mapping);

        /// <summary>
        ///     The result type of '{elseResultType}' in the else clause is invalid. The expected type is '{resultType}'.
        /// </summary>
        public static string CaseElseResultTypeUnexpected([CanBeNull] object elseResultType, [CanBeNull] object resultType)
            => string.Format(
                GetString("CaseElseResultTypeUnexpected", nameof(elseResultType), nameof(resultType)),
                elseResultType, resultType);

        /// <summary>
        ///     The result type of '{whenResultType}' in a when clause is invalid. The expected type is '{resultType}'.
        /// </summary>
        public static string CaseWhenClauseResultTypeUnexpected([CanBeNull] object whenResultType, [CanBeNull] object resultType)
            => string.Format(
                GetString("CaseWhenClauseResultTypeUnexpected", nameof(whenResultType), nameof(resultType)),
                whenResultType, resultType);

        /// <summary>
        ///     The operand type of '{whenOperandType}' in a when clause is invalid. The expected type is '{expectedWhenOperandType}'.
        /// </summary>
        public static string CaseWhenClauseTestTypeUnexpected([CanBeNull] object whenOperandType, [CanBeNull] object expectedWhenOperandType)
            => string.Format(
                GetString("CaseWhenClauseTestTypeUnexpected", nameof(whenOperandType), nameof(expectedWhenOperandType)),
                whenOperandType, expectedWhenOperandType);

        /// <summary>
        ///     The number of argument type mappings does not match the number of arguments.
        /// </summary>
        public static string SqlFunctionArgumentsAndMappingsMismatch
            => GetString("SqlFunctionArgumentsAndMappingsMismatch");

        /// <summary>
        ///     One of the specified argument type mappings was null.
        /// </summary>
        public static string SqlFunctionNullArgumentMapping
            => GetString("SqlFunctionNullArgumentMapping");

        /// <summary>
        ///     An instance type mapping was specified without an instance expression.
        /// </summary>
        public static string SqlFunctionUnexpectedInstanceMapping
            => GetString("SqlFunctionUnexpectedInstanceMapping");

        /// <summary>
        ///     Entity type '{entityType}' doesn't contain a property mapped to the store-generated concurrency token column '{missingColumn}' that is used by another entity type sharing the table '{table}'. Add a store-generated property mapped to the same column to '{entityType}'. It can be in shadow state.
        /// </summary>
        public static string MissingConcurrencyColumn([CanBeNull] object entityType, [CanBeNull] object missingColumn, [CanBeNull] object table)
            => string.Format(
                GetString("MissingConcurrencyColumn", nameof(entityType), nameof(missingColumn), nameof(table)),
                entityType, missingColumn, table);

        /// <summary>
        ///     This connection was used with an ambient transaction. The original ambient transaction needs to be completed before this connection can be used outside of it.
        /// </summary>
        public static string PendingAmbientTransaction
            => GetString("PendingAmbientTransaction");

        /// <summary>
        ///     Set operations (Union, Concat, Intersect, Except) are only supported over entity types within the same type hierarchy.
        /// </summary>
        public static string SetOperationNotWithinEntityTypeHierarchy
            => GetString("SetOperationNotWithinEntityTypeHierarchy");

        private static string GetString(string name, params string[] formatterNames)
        {
            var value = _resourceManager.GetString(name);
            for (var i = 0; i < formatterNames.Length; i++)
            {
                value = value.Replace("{" + formatterNames[i] + "}", "{" + i + "}");
            }

            return value;
        }
    }
}

namespace Microsoft.EntityFrameworkCore.Diagnostics.Internal
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static class RelationalResources
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Microsoft.EntityFrameworkCore.Properties.RelationalStrings", typeof(RelationalResources).GetTypeInfo().Assembly);

        /// <summary>
        ///     The 'bool' property '{property}' on entity type '{entityType}' is configured with a database-generated default. This default will always be used for inserts when the property has the value 'false', since this is the CLR default for the 'bool' type. Consider using the nullable 'bool?' type instead so that the default will only be used for inserts when the property value is 'null'.
        /// </summary>
        public static EventDefinition<string, string> LogBoolWithDefaultWarning([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBoolWithDefaultWarning;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBoolWithDefaultWarning,
                    () => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.BoolWithDefaultWarning,
                        LogLevel.Warning,
                        "RelationalEventId.BoolWithDefaultWarning",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.BoolWithDefaultWarning,
                            _resourceManager.GetString("LogBoolWithDefaultWarning"))));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Opening connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogOpeningConnection([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogOpeningConnection;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogOpeningConnection,
                    () => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionOpening,
                        LogLevel.Debug,
                        "RelationalEventId.ConnectionOpening",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionOpening,
                            _resourceManager.GetString("LogOpeningConnection"))));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Opened connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogOpenedConnection([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogOpenedConnection;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogOpenedConnection,
                    () => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionOpened,
                        LogLevel.Debug,
                        "RelationalEventId.ConnectionOpened",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionOpened,
                            _resourceManager.GetString("LogOpenedConnection"))));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Closing connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogClosingConnection([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogClosingConnection;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogClosingConnection,
                    () => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionClosing,
                        LogLevel.Debug,
                        "RelationalEventId.ConnectionClosing",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionClosing,
                            _resourceManager.GetString("LogClosingConnection"))));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Closed connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogClosedConnection([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogClosedConnection;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogClosedConnection,
                    () => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionClosed,
                        LogLevel.Debug,
                        "RelationalEventId.ConnectionClosed",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionClosed,
                            _resourceManager.GetString("LogClosedConnection"))));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     An error occurred using the connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogConnectionError([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogConnectionError;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogConnectionError,
                    () => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionError,
                        LogLevel.Error,
                        "RelationalEventId.ConnectionError",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionError,
                            _resourceManager.GetString("LogConnectionError"))));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Beginning transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static EventDefinition<string> LogBeginningTransaction([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBeginningTransaction;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBeginningTransaction,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.TransactionStarting,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionStarting",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.TransactionStarting,
                            _resourceManager.GetString("LogBeginningTransaction"))));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Began transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static EventDefinition<string> LogBeganTransaction([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBeganTransaction;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBeganTransaction,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.TransactionStarted,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionStarted",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.TransactionStarted,
                            _resourceManager.GetString("LogBeganTransaction"))));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Using an existing transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static EventDefinition<string> LogUsingTransaction([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogUsingTransaction;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogUsingTransaction,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.TransactionUsed,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionUsed",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.TransactionUsed,
                            _resourceManager.GetString("LogUsingTransaction"))));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Committing transaction.
        /// </summary>
        public static EventDefinition LogCommittingTransaction([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogCommittingTransaction;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogCommittingTransaction,
                    () => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionCommitting,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionCommitting",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionCommitting,
                            _resourceManager.GetString("LogCommittingTransaction"))));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Committed transaction.
        /// </summary>
        public static EventDefinition LogCommittedTransaction([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogCommittedTransaction;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogCommittedTransaction,
                    () => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionCommitted,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionCommitted",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionCommitted,
                            _resourceManager.GetString("LogCommittedTransaction"))));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Rolling back transaction.
        /// </summary>
        public static EventDefinition LogRollingBackTransaction([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogRollingBackTransaction;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogRollingBackTransaction,
                    () => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionRollingBack,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionRollingBack",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionRollingBack,
                            _resourceManager.GetString("LogRollingBackTransaction"))));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Rolled back transaction.
        /// </summary>
        public static EventDefinition LogRolledBackTransaction([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogRolledBackTransaction;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogRolledBackTransaction,
                    () => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionRolledBack,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionRolledBack",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionRolledBack,
                            _resourceManager.GetString("LogRolledBackTransaction"))));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Disposing transaction.
        /// </summary>
        public static EventDefinition LogDisposingTransaction([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogDisposingTransaction;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogDisposingTransaction,
                    () => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionDisposed,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionDisposed",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionDisposed,
                            _resourceManager.GetString("LogDisposingTransaction"))));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     An error occurred using a transaction.
        /// </summary>
        public static EventDefinition LogTransactionError([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogTransactionError;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogTransactionError,
                    () => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionError,
                        LogLevel.Error,
                        "RelationalEventId.TransactionError",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionError,
                            _resourceManager.GetString("LogTransactionError"))));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     A data reader was disposed.
        /// </summary>
        public static EventDefinition LogDisposingDataReader([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogDisposingDataReader;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogDisposingDataReader,
                    () => new EventDefinition(
                        logger.Options,
                        RelationalEventId.DataReaderDisposing,
                        LogLevel.Debug,
                        "RelationalEventId.DataReaderDisposing",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.DataReaderDisposing,
                            _resourceManager.GetString("LogDisposingDataReader"))));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     An ambient transaction has been detected. The current provider does not support ambient transactions. See http://go.microsoft.com/fwlink/?LinkId=800142
        /// </summary>
        public static EventDefinition LogAmbientTransaction([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogAmbientTransaction;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogAmbientTransaction,
                    () => new EventDefinition(
                        logger.Options,
                        RelationalEventId.AmbientTransactionWarning,
                        LogLevel.Warning,
                        "RelationalEventId.AmbientTransactionWarning",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.AmbientTransactionWarning,
                            _resourceManager.GetString("LogAmbientTransaction"))));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Possible unintended use of method Equals(object) for arguments of different types in expression '{expression}'. This comparison will always return 'false'.
        /// </summary>
        public static EventDefinition<object> LogPossibleUnintendedUseOfEquals([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogPossibleUnintendedUseOfEquals;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogPossibleUnintendedUseOfEquals,
                    () => new EventDefinition<object>(
                        logger.Options,
                        RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning,
                        LogLevel.Warning,
                        "RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning",
                        level => LoggerMessage.Define<object>(
                            level,
                            RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning,
                            _resourceManager.GetString("LogPossibleUnintendedUseOfEquals"))));
            }

            return (EventDefinition<object>)definition;
        }

        /// <summary>
        ///     Possible unintended use of a potentially throwing aggregate method (Min, Max, Average) in a subquery. Client evaluation will be used and operator will throw if no data exists. Changing the subquery result type to a nullable type will allow full translation.
        /// </summary>
        public static EventDefinition LogQueryPossibleExceptionWithAggregateOperatorWarning([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogQueryPossibleExceptionWithAggregateOperatorWarning;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogQueryPossibleExceptionWithAggregateOperatorWarning,
                    () => new EventDefinition(
                        logger.Options,
                        RelationalEventId.QueryPossibleExceptionWithAggregateOperatorWarning,
                        LogLevel.Warning,
                        "RelationalEventId.QueryPossibleExceptionWithAggregateOperatorWarning",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.QueryPossibleExceptionWithAggregateOperatorWarning,
                            _resourceManager.GetString("LogQueryPossibleExceptionWithAggregateOperatorWarning"))));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Generating down script for migration '{migration}'.
        /// </summary>
        public static EventDefinition<string> LogGeneratingDown([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogGeneratingDown;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogGeneratingDown,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationGeneratingDownScript,
                        LogLevel.Debug,
                        "RelationalEventId.MigrationGeneratingDownScript",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationGeneratingDownScript,
                            _resourceManager.GetString("LogGeneratingDown"))));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Generating up script for migration '{migration}'.
        /// </summary>
        public static EventDefinition<string> LogGeneratingUp([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogGeneratingUp;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogGeneratingUp,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationGeneratingUpScript,
                        LogLevel.Debug,
                        "RelationalEventId.MigrationGeneratingUpScript",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationGeneratingUpScript,
                            _resourceManager.GetString("LogGeneratingUp"))));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Applying migration '{migration}'.
        /// </summary>
        public static EventDefinition<string> LogApplyingMigration([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogApplyingMigration;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogApplyingMigration,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationApplying,
                        LogLevel.Information,
                        "RelationalEventId.MigrationApplying",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationApplying,
                            _resourceManager.GetString("LogApplyingMigration"))));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Reverting migration '{migration}'.
        /// </summary>
        public static EventDefinition<string> LogRevertingMigration([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogRevertingMigration;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogRevertingMigration,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationReverting,
                        LogLevel.Information,
                        "RelationalEventId.MigrationReverting",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationReverting,
                            _resourceManager.GetString("LogRevertingMigration"))));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Migrating using database '{database}' on server '{dataSource}'.
        /// </summary>
        public static EventDefinition<string, string> LogMigrating([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogMigrating;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogMigrating,
                    () => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.MigrateUsingConnection,
                        LogLevel.Debug,
                        "RelationalEventId.MigrateUsingConnection",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.MigrateUsingConnection,
                            _resourceManager.GetString("LogMigrating"))));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     No migrations were applied. The database is already up to date.
        /// </summary>
        public static EventDefinition LogNoMigrationsApplied([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogNoMigrationsApplied;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogNoMigrationsApplied,
                    () => new EventDefinition(
                        logger.Options,
                        RelationalEventId.MigrationsNotApplied,
                        LogLevel.Information,
                        "RelationalEventId.MigrationsNotApplied",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.MigrationsNotApplied,
                            _resourceManager.GetString("LogNoMigrationsApplied"))));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     No migrations were found in assembly '{migrationsAssembly}'.
        /// </summary>
        public static EventDefinition<string> LogNoMigrationsFound([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogNoMigrationsFound;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogNoMigrationsFound,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationsNotFound,
                        LogLevel.Debug,
                        "RelationalEventId.MigrationsNotFound",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationsNotFound,
                            _resourceManager.GetString("LogNoMigrationsFound"))));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Property '{property}' on entity type '{entityType}' is part of a primary or alternate key but has a constant default value set. Constant default values are not useful for primary or alternate keys since these properties must always have non-null unqiue values.
        /// </summary>
        public static EventDefinition<string, string> LogKeyHasDefaultValue([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogKeyHasDefaultValue;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogKeyHasDefaultValue,
                    () => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ModelValidationKeyDefaultValueWarning,
                        LogLevel.Warning,
                        "RelationalEventId.ModelValidationKeyDefaultValueWarning",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ModelValidationKeyDefaultValueWarning,
                            _resourceManager.GetString("LogKeyHasDefaultValue"))));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     The LINQ expression '{expression}' could not be translated and will be evaluated locally.
        /// </summary>
        [Obsolete]
        public static EventDefinition<object> LogClientEvalWarning([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogClientEvalWarning;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogClientEvalWarning,
                    () => new EventDefinition<object>(
                        logger.Options,
                        RelationalEventId.QueryClientEvaluationWarning,
                        LogLevel.Warning,
                        "RelationalEventId.QueryClientEvaluationWarning",
                        level => LoggerMessage.Define<object>(
                            level,
                            RelationalEventId.QueryClientEvaluationWarning,
                            _resourceManager.GetString("LogClientEvalWarning"))));
            }

            return (EventDefinition<object>)definition;
        }

        /// <summary>
        ///     Executing DbCommand [Parameters=[{parameters}], CommandType='{commandType}', CommandTimeout='{commandTimeout}']{newLine}{commandText}
        /// </summary>
        public static EventDefinition<string, System.Data.CommandType, int, string, string> LogExecutingCommand([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogExecutingCommand;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogExecutingCommand,
                    () => new EventDefinition<string, System.Data.CommandType, int, string, string>(
                        logger.Options,
                        RelationalEventId.CommandExecuting,
                        LogLevel.Information,
                        "RelationalEventId.CommandExecuting",
                        level => LoggerMessage.Define<string, System.Data.CommandType, int, string, string>(
                            level,
                            RelationalEventId.CommandExecuting,
                            _resourceManager.GetString("LogExecutingCommand"))));
            }

            return (EventDefinition<string, System.Data.CommandType, int, string, string>)definition;
        }

        /// <summary>
        ///     Executed DbCommand ({elapsed}ms) [Parameters=[{parameters}], CommandType='{commandType}', CommandTimeout='{commandTimeout}']{newLine}{commandText}
        /// </summary>
        public static EventDefinition<string, string, System.Data.CommandType, int, string, string> LogExecutedCommand([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogExecutedCommand;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogExecutedCommand,
                    () => new EventDefinition<string, string, System.Data.CommandType, int, string, string>(
                        logger.Options,
                        RelationalEventId.CommandExecuted,
                        LogLevel.Debug,
                        "RelationalEventId.CommandExecuted",
                        level => LoggerMessage.Define<string, string, System.Data.CommandType, int, string, string>(
                            level,
                            RelationalEventId.CommandExecuted,
                            _resourceManager.GetString("LogExecutedCommand"))));
            }

            return (EventDefinition<string, string, System.Data.CommandType, int, string, string>)definition;
        }

        /// <summary>
        ///     Failed executing DbCommand ({elapsed}ms) [Parameters=[{parameters}], CommandType='{commandType}', CommandTimeout='{commandTimeout}']{newLine}{commandText}
        /// </summary>
        public static EventDefinition<string, string, System.Data.CommandType, int, string, string> LogCommandFailed([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogCommandFailed;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogCommandFailed,
                    () => new EventDefinition<string, string, System.Data.CommandType, int, string, string>(
                        logger.Options,
                        RelationalEventId.CommandError,
                        LogLevel.Error,
                        "RelationalEventId.CommandError",
                        level => LoggerMessage.Define<string, string, System.Data.CommandType, int, string, string>(
                            level,
                            RelationalEventId.CommandError,
                            _resourceManager.GetString("LogCommandFailed"))));
            }

            return (EventDefinition<string, string, System.Data.CommandType, int, string, string>)definition;
        }

        /// <summary>
        ///     An error occurred using the connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogConnectionErrorAsDebug([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogConnectionErrorAsDebug;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogConnectionErrorAsDebug,
                    () => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionError,
                        LogLevel.Debug,
                        "RelationalEventId.ConnectionError",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionError,
                            _resourceManager.GetString("LogConnectionErrorAsDebug"))));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Enlisted in an ambient transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static EventDefinition<string> LogAmbientTransactionEnlisted([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogAmbientTransactionEnlisted;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogAmbientTransactionEnlisted,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.AmbientTransactionEnlisted,
                        LogLevel.Debug,
                        "RelationalEventId.AmbientTransactionEnlisted",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.AmbientTransactionEnlisted,
                            _resourceManager.GetString("LogAmbientTransactionEnlisted"))));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Enlisted in an explicit transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static EventDefinition<string> LogExplicitTransactionEnlisted([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogExplicitTransactionEnlisted;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogExplicitTransactionEnlisted,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.ExplicitTransactionEnlisted,
                        LogLevel.Debug,
                        "RelationalEventId.ExplicitTransactionEnlisted",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.ExplicitTransactionEnlisted,
                            _resourceManager.GetString("LogExplicitTransactionEnlisted"))));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Executing update commands individually as the number of batchable commands ({batchableCommandsCount}) is smaller than the minimum batch size ({minBatchSize}).
        /// </summary>
        public static EventDefinition<int, int> LogBatchSmallerThanMinBatchSize([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBatchSmallerThanMinBatchSize;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBatchSmallerThanMinBatchSize,
                    () => new EventDefinition<int, int>(
                        logger.Options,
                        RelationalEventId.BatchSmallerThanMinBatchSize,
                        LogLevel.Debug,
                        "RelationalEventId.BatchSmallerThanMinBatchSize",
                        level => LoggerMessage.Define<int, int>(
                            level,
                            RelationalEventId.BatchSmallerThanMinBatchSize,
                            _resourceManager.GetString("LogBatchSmallerThanMinBatchSize"))));
            }

            return (EventDefinition<int, int>)definition;
        }

        /// <summary>
        ///     Executing {batchCommandsCount} update commands as a batch.
        /// </summary>
        public static EventDefinition<int> LogBatchReadyForExecution([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBatchReadyForExecution;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBatchReadyForExecution,
                    () => new EventDefinition<int>(
                        logger.Options,
                        RelationalEventId.BatchReadyForExecution,
                        LogLevel.Debug,
                        "RelationalEventId.BatchReadyForExecution",
                        level => LoggerMessage.Define<int>(
                            level,
                            RelationalEventId.BatchReadyForExecution,
                            _resourceManager.GetString("LogBatchReadyForExecution"))));
            }

            return (EventDefinition<int>)definition;
        }

        /// <summary>
        ///     A MigrationAttribute isn't specified on the '{class}' class.
        /// </summary>
        public static EventDefinition<string> LogMigrationAttributeMissingWarning([NotNull] IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogMigrationAttributeMissingWarning;
            if (definition == null)
            {
                definition = LazyInitializer.EnsureInitialized<EventDefinitionBase>(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogMigrationAttributeMissingWarning,
                    () => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationAttributeMissingWarning,
                        LogLevel.Warning,
                        "RelationalEventId.MigrationAttributeMissingWarning",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationAttributeMissingWarning,
                            _resourceManager.GetString("LogMigrationAttributeMissingWarning"))));
            }

            return (EventDefinition<string>)definition;
        }
    }
}
